// This file is a STYLE REFERENCE for generated <prno>_test_e2e.go.
// Do not run it; it assumes the ZTWIM repo test/e2e suite and utils exist.
// Copy patterns (Describe/Context/It, By, utils.*, k8sClient, testCtx) into the real repo.

package e2e

import (
	"context"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	operatorv1alpha1 "github.com/openshift/zero-trust-workload-identity-manager/api/v1alpha1"
	"github.com/openshift/zero-trust-workload-identity-manager/test/e2e/utils"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// PR-suggested: Example Context for operand status aggregation.
// Copy this block into e2e_test.go or keep in <prno>_test_e2e.go inside the main Describe.
var _ = Describe("PR-suggested e2e", Ordered, func() {
	var testCtx context.Context

	BeforeEach(func() {
		var cancel context.CancelFunc
		testCtx, cancel = context.WithTimeout(context.Background(), utils.DefaultTimeout)
		DeferCleanup(cancel)
	})

	// Important scenario: ZTWIM aggregates operand status (all 4 operands Ready).
	Context("ZeroTrustWorkloadIdentityManager operand status", func() {
		It("should report all operands Ready in status", func() {
			By("Waiting for ZeroTrustWorkloadIdentityManager to show all operands available")
			utils.WaitForZeroTrustWorkloadIdentityManagerConditions(testCtx, k8sClient, "cluster", map[string]metav1.ConditionStatus{
				"OperandsAvailable": metav1.ConditionTrue,
				"Ready":             metav1.ConditionTrue,
			}, utils.DefaultTimeout)

			By("Verifying ZeroTrustWorkloadIdentityManager operand status")
			cr := &operatorv1alpha1.ZeroTrustWorkloadIdentityManager{}
			err := k8sClient.Get(testCtx, client.ObjectKey{Name: "cluster"}, cr)
			Expect(err).NotTo(HaveOccurred(), "failed to get ZeroTrustWorkloadIdentityManager")
			Expect(cr.Status.Operands).To(HaveLen(4), "should have 4 operands")
			requiredOperands := []string{"SpireServer", "SpireAgent", "SpiffeCSIDriver", "SpireOIDCDiscoveryProvider"}
			operandMap := make(map[string]operatorv1alpha1.OperandStatus)
			for _, o := range cr.Status.Operands {
				operandMap[o.Kind] = o
			}
			for _, kind := range requiredOperands {
				operand, exists := operandMap[kind]
				Expect(exists).To(BeTrue(), "%s operand should exist", kind)
				Expect(operand.Ready).To(Equal("true"), "%s should be ready", kind)
			}
		})
	})

	// Important scenario: OperatorCondition Upgradeable when healthy.
	Context("OperatorCondition Upgradeable", func() {
		It("should be True when all operands are ready", func() {
			By("Getting OperatorCondition name for the operator")
			operatorConditionName, _, err := utils.FindOperatorConditionName(testCtx, k8sClient, utils.OperatorNamespace, utils.OperatorSubscriptionNameFragment)
			Expect(err).NotTo(HaveOccurred())

			By("Verifying Upgradeable condition is True")
			condition, err := utils.GetUpgradeableCondition(testCtx, k8sClient, utils.OperatorNamespace, operatorConditionName)
			Expect(err).NotTo(HaveOccurred())
			Expect(condition.Status).To(Equal(metav1.ConditionTrue), "Upgradeable should be True")
			Expect(condition.Reason).To(Equal(operatorv1alpha1.ReasonReady), "Upgradeable reason should be Ready")
		})
	})
})
